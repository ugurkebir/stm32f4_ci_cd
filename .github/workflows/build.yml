# .github/workflows/build.yml

name: STM32F4 CI/CD Build

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-firmware:
    name: Build STM32F4 Firmware

    # We call the Runner as we tagged it. This is correct.
    # Our macOS runner will pick up the job because it has these labels.
    runs-on: [self-hosted, linux, arm64]

    steps:
      # Step 1: Checkout the code
      # This step runs directly on the macOS runner.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Build the firmware
      # We will run this step manually inside Docker.
      - name: Build firmware
        run: |
          # We tell our macOS runner to run a command using Docker:
          # --rm = Remove the container once the job is done.
          # -v "${{ github.workspace }}:/app" = Mount the checked-out code (on macOS)
          #     to the /app folder inside the container.
          # -w /app = Set the working directory inside the container to /app.
          # ugurkebir/stm32f4-build:14.3-rel1 = The image to use.
          # make -j"$(nproc)" = The command to run inside the image.
          docker run --rm -v "${{ github.workspace }}:/app" -w /app/base_app \
          docker.io/ugurkebir/stm32f4-build:14.3-rel1 \
          make -j"$(nproc)"

      # Step 3: Create .hex and .bin files
      # We will run this step manually inside Docker.
      - name: Create HEX and BIN files
        run: |
          docker run --rm -v "${{ github.workspace }}:/app" -w /app/base_app \
          docker.io/ugurkebir/stm32f4-build:14.3-rel1 \
          sh -c "if ls build/*.elf >/dev/null 2>&1; then \
                    arm-none-eabi-objcopy -O ihex build/*.elf build/firmware.hex; \
                    arm-none-eabi-objcopy -O binary build/*.elf build/firmware.bin; \
                 else \
                    echo 'Error: No .elf file found after compilation.'; \
                    exit 1; \
                 fi"

      # Step 4: Upload artifacts
      # This step runs again on the macOS runner and takes the files from
      # the 'build' folder (because Docker wrote there).
      - name: Upload firmware artifacts
        uses: actions/upload-artifact@v4
        with:
          name: stm32-firmware
          path: |
            build/*.elf
            build/*.hex
            build/*.bin

  # Unit tests job
  unit-tests:
    name: Unit Tests
    needs: build-firmware 
    runs-on: [self-hosted, linux, arm64]
    
    steps:
      - name: Run unit tests
        # If needed, you can also run this inside a container using 'docker run ...'
        # command.
        run: echo "No unit tests yet (running on host)"